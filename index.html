<!DOCTYPE html>
<html lang="en">
	
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <title>Sonic/Blend Radio Player</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Orbitron', sans-serif;
            color: #a0a0a0;
            background: #000000;
            overflow: hidden;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            background: linear-gradient(45deg, #000000, #0a0a1a, #000000);
            position: relative;
        }
        .station-info {
            text-align: center;
            margin-bottom: 20px;
        }
        .station-name {
            font-size: 3.3em;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: #0066cc; /* Lighter title color */
           /* font-weight: bold;*/
            margin-bottom: 10px;
        }
        .track-info {
            font-size: 1em;
            color: #0066cc;
            margin-top: 10px;
            margin-bottom: 30px; /* Added space below the widget */
            padding: 15px;
            background-color: rgba(26, 26, 58, 0.4);
            border-radius: 5px;
            max-width: 80%;
            margin-left: auto;
            margin-right: auto;
            border: 2px solid #0066cc;
            box-shadow: 0 0 10px #0066cc;
            text-align: center; /* Center the text */
        }
        .now-playing {
           /* font-weight: bold;*/
            margin-bottom: 5px;
           /* color: #ffffff;*/
        }
        .track-title-artist {
            font-size: 1.1em;
            margin: 5px 0;
        }
        #visualizer {
            width: 90%;
            height: 60%; /* 200px; */
            background-color: rgba(10, 10, 26, 0.6);
            border: 2px solid #1a1a3a;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 0 20px #0066cc;
        }
        #controls {
            display: flex;
            gap: 20px;
            align-items: center;
            background-color: rgba(26, 26, 58, 0.4);
            padding: 15px;
            border-radius: 25px;
            border: 1px solid #3a3a5a;
        }
        #playPauseBtn, #switchVisualizerBtn {
            background-color: #0066cc;
            color: #a0a0a0;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        #playPauseBtn:hover, #switchVisualizerBtn:hover {
            background-color: #004499;
            box-shadow: 0 0 15px #0066cc;
        }
        #volumeSlider {
            -webkit-appearance: none;
            width: 150px;
            height: 5px;
            background: #3a3a5a;
            outline: none;
            border-radius: 5px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        #volumeSlider:hover {
            opacity: 1;
        }
        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: #0066cc;
            cursor: pointer;
            border-radius: 50%;
        }
        #volumeSlider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: #0066cc;
            cursor: pointer;
            border-radius: 50%;
        }
        .glitch {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('/api/placeholder/1920/1080') no-repeat center center;
            background-size: cover;
            opacity: 0.05;
            mix-blend-mode: overlay;
            pointer-events: none;
        }
		#fullscreenBtn {
            background-color: #0066cc;
            color: #a0a0a0;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            margin-left: 20px;
        }
        #fullscreenBtn:hover {
            background-color: #004499;
            box-shadow: 0 0 15px #0066cc;
        }
		 #switchVisualizerBtn.random {
            background-color: #cc6600;
        }
        #randomChangeText {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #0066cc;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
    </style>

</head>
<body>
    <div class="container">
        <div class="glitch"></div>
        <div class="station-info">
            <h1 class="station-name">Sonic.Blend</h1>
        </div>
        <canvas id="visualizer"></canvas>
		 <div id="randomChangeText">Random change</div>
        <div class="track-info" id="trackInfo">
            <div class="now-playing">Now Playing:</div>
            <div class="track-title-artist">Loading track information...</div>
        </div>
        <div id="controls">
            <button id="playPauseBtn"><i class="fas fa-play"></i></button>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1">
            <button id="switchVisualizerBtn"><i class="fas fa-cube"></i></button>
			<button id="fullscreenBtn"><i class="fas fa-expand"></i></button>
        </div>
    </div>

    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 512;
        
        const audio = new Audio();
        audio.crossOrigin = "anonymous";
        audio.src = "http://130.162.248.119:8000/radio.mp3";
        
        const source = audioContext.createMediaElementSource(audio);
        source.connect(analyser);
        analyser.connect(audioContext.destination);
        
        const playPauseBtn = document.getElementById('playPauseBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const switchVisualizerBtn = document.getElementById('switchVisualizerBtn');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        const trackInfoElement = document.getElementById('trackInfo');
         let isWebGLAvailable = false;
       let currentVisualizer = 0;
	   
	      // Initialize Three.js scene
          isWebGLAvailable = initThreeJS();
       /* if (isWebGLAvailable) {
            totalVisualizers = 12; // Include the 3D visualizer
        }*/
		
        const totalVisualizers = isWebGLAvailable ? 12 : 11;
		let randomVisualizerInterval;
        let particles = [];
        let time = 0;
		
		
		
		    // Three.js variables
        let scene, camera, renderer, cubes = [];
       
		
        playPauseBtn.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            if (audio.paused) {
                audio.play();
            } else {
                audio.pause();
            }
        });
        
        volumeSlider.addEventListener('input', (e) => {
            audio.volume = e.target.value;
        });
        
        switchVisualizerBtn.addEventListener('click', () => {
            currentVisualizer = (currentVisualizer + 1) % totalVisualizers;
            if (currentVisualizer === 1) {
                initParticles();
            }
        });
		
		  let isRandomMode = false;
        let fadeTimeout;
		
		function changeVisualizer(direction) {
			if (isRandomMode) {
			stopRandomVisualizer();
			currentVisualizer =0;}
			else
			if (currentVisualizer === totalVisualizers - 1) {
                startRandomVisualizer();
            } 
			else
            {currentVisualizer = (currentVisualizer + direction) % totalVisualizers;}
         
            updateVisualizerButton();
        }

          function startRandomVisualizer() {
            isRandomMode = true;
            randomVisualizerInterval = setInterval(() => {
                currentVisualizer = Math.floor(Math.random() * (totalVisualizers - 1));
                showRandomChangeText();
            }, 30000);
            updateVisualizerButton();
        }

         function stopRandomVisualizer() {
            isRandomMode = false;
            clearInterval(randomVisualizerInterval);
            updateVisualizerButton();
        }
		
		function updateVisualizerButton() {
            if (isRandomMode) {
                switchVisualizerBtn.classList.add('random');
                switchVisualizerBtn.innerHTML = '<i class="fas fa-random"></i>';
            } else {
                switchVisualizerBtn.classList.remove('random');
                switchVisualizerBtn.innerHTML = '<i class="fas fa-cube"></i>';
            }
        }


		function showRandomChangeText() {
            const randomChangeText = document.getElementById('randomChangeText');
            randomChangeText.style.opacity = '1';
            clearTimeout(fadeTimeout);
            fadeTimeout = setTimeout(() => {
                randomChangeText.style.opacity = '0';
            }, 2000);
        }
		
        switchVisualizerBtn.addEventListener('click', () => changeVisualizer(1));

        // Add keyboard event listener for left and right arrow keys
        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowLeft') {
                changeVisualizer(-1);
            } else if (event.key === 'ArrowRight') {
                changeVisualizer(1);
            }
        });


		
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const visualizer = document.getElementById('visualizer');

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                if (visualizer.requestFullscreen) {
                    visualizer.requestFullscreen();
                } else if (visualizer.mozRequestFullScreen) { // Firefox
                    visualizer.mozRequestFullScreen();
                } else if (visualizer.webkitRequestFullscreen) { // Chrome, Safari and Opera
                    visualizer.webkitRequestFullscreen();
                } else if (visualizer.msRequestFullscreen) { // IE/Edge
                    visualizer.msRequestFullscreen();
                }
                fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
            }
        }

        fullscreenBtn.addEventListener('click', toggleFullScreen);
        visualizer.addEventListener('dblclick', toggleFullScreen);

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
            }
        });
		
        
        function drawBarVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
           
            canvasCtx.fillStyle = 'rgba(10, 10, 56, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i] / 0.6;
                const gradient = canvasCtx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                gradient.addColorStop(0, '#0066cc');
                gradient.addColorStop(1, '#3a3a5a');
                canvasCtx.fillStyle = gradient;
                canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }
        
        function initParticles() {
            particles = [];
            for (let i = 0; i < 500; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    z: Math.random() * 100,
                    size: Math.random() * 15 + 1,
                    speed: Math.random() * 0.5 + 0.1
                });
            }
        }
        

        let dispositionX =1;
        let dispositionY =1;
        let nextX =0;
        let nextY =0;
        function drawParticleVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            canvasCtx.fillStyle = 'rgba(10, 10, 56, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const amp=new Uint8Array(bufferLength);
            
            analyser.getByteTimeDomainData(amp);
            let uvmeter = dataArray[3];
         
            //canvasCtx.fillStyle = `rgb(0, ${uvmeter+50}, ${uvmeter+50})`;
            canvasCtx.beginPath();
            canvasCtx.arc(centerX+nextX, centerY+nextY, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();

           /* canvasCtx.beginPath();
            canvasCtx.arc(centerX-100, centerY-100, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();

            canvasCtx.beginPath();
            canvasCtx.arc(centerX+100, centerY-100, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();*/

            
            uvmeter = dataArray[95];
            canvasCtx.beginPath();
            canvasCtx.arc(centerX-200+nextX, centerY-50+nextY, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();

            uvmeter = dataArray[115];
            canvasCtx.beginPath();
            canvasCtx.arc(centerX-200+nextX, centerY+nextY, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();

            uvmeter = dataArray[135];
            canvasCtx.beginPath();
            canvasCtx.arc(centerX-100+nextX, centerY+50+nextY, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();

            uvmeter = dataArray[165];
            canvasCtx.beginPath();
            canvasCtx.arc(centerX+250+nextX, centerY+nextY, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();

            uvmeter = dataArray[145];
            canvasCtx.beginPath();
            canvasCtx.arc(centerX+150+nextX, centerY-50+nextY, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();

            uvmeter = dataArray[185];
            canvasCtx.beginPath();
            canvasCtx.arc(centerX+150+nextX, centerY+50+nextY, 0.8 * uvmeter, 0, Math.PI * 2);
            //canvasCtx.fill();
            canvasCtx.strokeStyle = `hsl(192, ${uvmeter+10}%, ${uvmeter*0.1+40}%)`;
            canvasCtx.lineWidth = 1;
            canvasCtx.stroke();
            

            nextX = nextX+dispositionX;
            nextY = nextY+dispositionY;
            if (nextX>100) {dispositionX=-1;}
            if (nextX<-100) {dispositionX=1;}
            if (nextY>100) {dispositionY=-1;}
            if (nextY<-100) {dispositionY=1;}

            particles.forEach((particle, index) => {
                particle.z -= particle.speed;
                if (particle.z <= 0) {
                    particle.z = 200;
                }
                
                const scale = 200 / (200 - particle.z);
                const x2d = (particle.x - centerX) * scale + centerX;
                const y2d = (particle.y - centerY) * scale + centerY;
                
                const colorIntensity = dataArray[index % bufferLength] / 255;
                const color = `rgb(${Math.floor(colorIntensity * 0)}, ${Math.floor(colorIntensity * 0)}, ${Math.floor(colorIntensity * 150)+100})`;
                
                canvasCtx.fillStyle = color;
                canvasCtx.beginPath();
                canvasCtx.arc(x2d, y2d, particle.size * scale, 0, Math.PI * 2);
                canvasCtx.fill();
            });

        }
        
        function drawWaveformVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            canvasCtx.fillStyle = 'rgba(10, 10, 56, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#0066cc';
            canvasCtx.beginPath();
            
            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;
                
                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            canvasCtx.lineTo(canvas.width, canvas.height / 2);
            canvasCtx.stroke();
        }
        
        function drawCircularVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            canvasCtx.fillStyle = 'rgba(10, 10, 56, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 10;
            
            canvasCtx.beginPath();
            canvasCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            canvasCtx.strokeStyle = '#0066cc';
            canvasCtx.lineWidth = 2;
            canvasCtx.stroke();
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i] / 2;
                const rads = Math.PI * 2 / bufferLength;
                const x = centerX + Math.cos(rads * i) * (radius - barHeight);
                const y = centerY + Math.sin(rads * i) * (radius - barHeight);
                
                canvasCtx.beginPath();
                canvasCtx.moveTo(centerX, centerY);
                canvasCtx.lineTo(x, y);
                canvasCtx.strokeStyle = `hsl(${i * 360 / bufferLength}, 100%, 50%)`;
                canvasCtx.lineWidth = 2;
                canvasCtx.stroke();
            }
        }
        
        function drawSpectrogramVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            canvasCtx.fillStyle = 'rgba(10, 10, 56, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = canvas.width / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = canvas.height;
                const y = canvas.height - barHeight;
                
                const hue = i * 360 / bufferLength;
                const saturation = 100;
                const lightness = dataArray[i] / 2;
                
                canvasCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                canvasCtx.fillRect(x, y, barWidth, barHeight);
                
                x += barWidth;
            }
        }
        
		let anglestep = -0.001; 
		let prevangel = 0.5;
		let centerX = canvas.width / 2;
        let   startY = canvas.height;
		let ystep = -2;
		let xstep = -1;
		let rotstep = 0.01;
		let rotangle = 0;
		let pausemove = 0;
		let branchextension = 0.57;
		let extensionstep = 0.001;
		let pauseex=0;
		let branchlegth=0.33;
		let lengthstep=0.001;
		let variation=0;
		let pausevar=0
		
         function drawFractalTreeVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            canvasCtx.fillStyle = 'rgba(10, 10, 56, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

             
		     

            function drawBranch(x, y, length, angle, depth) {
                if (depth === 0) return;
				let endX,endY;
				switch (variation){
				case 1:
					 endX = x + length * Math.tan(angle);
					 endY = y - length * Math.atan(angle);
				break;
				case 2:
					endX = x + length * Math.sin(angle);
					endY = y - length * Math.tan(angle);
				break;
				case 3:
					endX = x + length * Math.cos(angle);
					endY = y - length * Math.atan(angle);
				break;
				default:
					 endX = x + length * Math.sin(angle);
					 endY = y - length * Math.cos(angle);
				}
                // endX = x + length * Math.sin(angle);
                // endY = y - length * Math.cos(angle);
				
				const sat = 100*(dataArray[depth % bufferLength] / 255);
				const amplitude = 30+sat*0.3;
				
                const hue = (dataArray[depth] / 255) * 360;
                canvasCtx.strokeStyle = `hsl(${hue}, ${sat}%, ${amplitude}% )`;
                canvasCtx.lineWidth = depth/4.5;

                canvasCtx.beginPath();
                canvasCtx.moveTo(x, y);
                canvasCtx.lineTo(endX, endY);
                canvasCtx.stroke();

                const branchLength = length *branchextension;
                const newDepth = depth - 1;

                drawBranch(endX, endY, branchLength, angle - branchlegth, newDepth);
                drawBranch(endX, endY, branchLength, angle + branchlegth, newDepth);
				/* drawBranch(endX, endY, branchLength, angle - 0.33, newDepth);
                drawBranch(endX, endY, branchLength, angle + 0.33, newDepth);*/
            }
		    
		
			
			if (pausevar<=0){
			let rarvar = Math.random();
			switch (true){
				case (rarvar<=0.15):
					variation=1;
				break;
				case (rarvar>=0.90):
					variation=2;
					break;
			   case (rarvar<0.90 && rarvar>=0.80 ):
					variation=3;
					break;
				default:
					variation=0;
			}
			pausevar=315;
			}
			pausevar=pausevar-1;
            const maxDepth = 10;/*Math.floor((dataArray[0] / 255) * 10) + 5;*/
			drawBranch(centerX, startY, canvas.height * prevangel*0.66, -rotangle  , maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel, rotangle, maxDepth);
            drawBranch(centerX, startY, canvas.height * prevangel*0.66, -rotangle / 2, maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel, rotangle / 2, maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel*0.44, -rotangle / 4, maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel, rotangle / 4, maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel*0.66, (rotangle+Math.PI/2)%Math.PI , maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel*0.77, (rotangle-Math.PI/2)%Math.PI , maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel*0.44, (-rotangle-Math.PI/2)%Math.PI , maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel*0.33, (rotangle+2)%Math.PI , maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel*0.33, -(rotangle+2)%Math.PI , maxDepth);
			/*drawBranch(centerX, startY, canvas.height * prevangel, 0, maxDepth);
			drawBranch(centerX, startY, canvas.height * prevangel, Math.PI , maxDepth);*/
			
			branchlegth=branchlegth+lengthstep;
			if (branchlegth>=0.66) {lengthstep=-0.001;}
			if (branchlegth>=0.33) {lengthstep=0.001;}
			
			
			branchextension = branchextension+extensionstep;
			if (branchextension>1.2){extensionstep=-0.001;}
			if (branchextension<0.65){extensionstep=+0.001;}
		    rotangle = (rotangle+rotstep) ;
			
			//randomize extension
			let ranex = Math.random();
			if (pauseex<=0 && ranex <=0.02){
			branchextension=0.65;
			pauseex=250;}
			if (pauseex<=0 &&  ranex >=0.50 && ranex >=0.52){
			branchextension=0.9;
			pauseex=250;}
			if (pauseex<=0 && ranex >=0.98){
			branchextension=1.2;
			pauseex=250;}
			pauseex=pauseex-1;
			
		    /*if (Math.random() < 0.01) {
			prevangel = Math.random * Math.PI;}*/
			if (rotangle>= Math.PI) {rotstep=-0.01};
			if (rotangle<= 0) {rotstep=0.01};
			prevangel =prevangel + anglestep;
			if (prevangel < 0.15) {anglestep = 0.003;}
			if (prevangel > 0.5) {anglestep = -0.003;}
			centerX = centerX + xstep;
			startY = startY+ystep;
			if (startY > canvas.height-100) {ystep = -2;}
			if (startY <= 100) {ystep = 2;}
			if (centerX > canvas.width-100) {xstep = -1;}
			if (centerX <= 100) {xstep = 1;}
			
			//randomize x origin
			let ran = Math.random();
			if (pausemove<=0 && ran <= 0.01) {
			centerX =  canvas.width/2;
			pausemove=200;}
			if (pausemove<=0 && ran >= 0.99) {
			centerX =  200;
			pausemove=200;}
			if (pausemove<=0 && ran >= 0.50 && ran <= 0.51) {
			centerX =  canvas.width-200;
			pausemove=200;
			}
			pausemove=pausemove-1;
        }

     function drawKaleidoscopeVisualizer() {
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    analyser.getByteFrequencyData(dataArray);

    canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) * 0.8;
    const segments = 8;

    for (let i = 0; i < bufferLength; i++) {
        const amplitude = dataArray[i] / 255;
        const hue = (i / bufferLength) * 360;
        
        canvasCtx.save();
        canvasCtx.translate(centerX, centerY);

        for (let j = 0; j < segments; j++) {
            canvasCtx.rotate((Math.PI * 2) / segments);
            
            const x = (i / bufferLength) * radius;
            const y = amplitude * radius / 2;

            canvasCtx.fillStyle = `hsla(${hue}, 100%, 50%, ${amplitude})`;
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, amplitude * 10, 0, Math.PI * 2);
            canvasCtx.fill();

            canvasCtx.strokeStyle = `hsla(${hue}, 100%, 80%, ${amplitude * 0.5})`;
            canvasCtx.lineWidth = amplitude * 5;
            canvasCtx.beginPath();
            canvasCtx.moveTo(0, 0);
            canvasCtx.lineTo(x, y);
            canvasCtx.stroke();
        }

        canvasCtx.restore();
    }
}



function drawGeometricKaleidoscopeVisualizer() {
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    analyser.getByteFrequencyData(dataArray);

    canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);
    const segments = 12;
    const layers = 5;

    function drawPolygon(x, y, radius, sides, rotation) {
        canvasCtx.beginPath();
        for (let i = 0; i < sides; i++) {
            const angle = (i / sides) * Math.PI * 2 + rotation;
            const px = x + Math.cos(angle) * radius;
            const py = y + Math.sin(angle) * radius;
            if (i === 0) canvasCtx.moveTo(px, py);
            else canvasCtx.lineTo(px, py);
        }
        canvasCtx.closePath();
    }

    for (let layer = 0; layer < layers; layer++) {
        const layerRadius = (layer + 1) * (maxRadius / layers);
        const dataOffset = Math.floor((layer / layers) * bufferLength);
        
        for (let seg = 0; seg < segments; seg++) {
            canvasCtx.save();
            canvasCtx.translate(centerX, centerY);
            canvasCtx.rotate((seg / segments) * Math.PI * 2);

            const amplitude = dataArray[dataOffset + seg] / 255;
            const hue = (dataOffset + seg) * (360 / bufferLength);
            const sides = 3 + Math.floor(amplitude * 4);  // 3 to 7 sides

            // Draw polygon
            canvasCtx.fillStyle = `hsla(${hue}, 100%, 50%, ${amplitude * 0.5})`;
            canvasCtx.strokeStyle = `hsla(${hue}, 100%, 80%, ${amplitude * 0.8})`;
            canvasCtx.lineWidth = 2 + amplitude * 3;

            drawPolygon(layerRadius, 0, layerRadius * amplitude * 0.3, sides, layer * Math.PI / 4);
            canvasCtx.fill();
            canvasCtx.stroke();

            // Draw connecting lines
            canvasCtx.beginPath();
            canvasCtx.moveTo(0, 0);
            canvasCtx.lineTo(layerRadius, 0);
            canvasCtx.stroke();

            canvasCtx.restore();
        }
    }
}

        function drawLissajousVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            canvasCtx.fillStyle = 'rgba(10, 10, 56, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.8;

            canvasCtx.strokeStyle = '#0066cc';
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath();

            const a = (dataArray[0] / 255) * 5 + 1;
            const b = (dataArray[1] / 255) * 5 + 1;

            for (let t = 0; t < Math.PI * 2; t += 0.01) {
                const x = centerX + radius * Math.sin(a * t);
                const y = centerY + radius * Math.sin(b * t);

                if (t === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }
            }

            canvasCtx.stroke();
        }

        function drawFluidSimulationVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            canvasCtx.fillStyle = 'rgba(10, 10, 56, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            const particles = [];
            const numParticles = 100;

            for (let i = 0; i < numParticles; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: 0,
                    vy: 0
                });
            }

            const audioIntensity = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
            const force = audioIntensity / 50;

            particles.forEach(particle => {
                const angle = Math.atan2(particle.y - canvas.height / 2, particle.x - canvas.width / 2);
                particle.vx += Math.cos(angle) * force;
                particle.vy += Math.sin(angle) * force;

                particle.x += particle.vx;
                particle.y += particle.vy;

                particle.vx *= 0.99;
                particle.vy *= 0.99;

                if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
                if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;

                canvasCtx.fillStyle = `hsla(${(audioIntensity / 255) * 360}, 100%, 50%, 0.5)`;
                canvasCtx.beginPath();
                canvasCtx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                canvasCtx.fill();
            });
        }
		
let nodes = [];
const nodeCount = 10;
const maxConnections = 2;

function initializeNodes() {
    for (let i = 0; i < nodeCount; i++) {
        nodes.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            targetX: Math.random() * canvas.width,
            targetY: Math.random() * canvas.height,
            radius: Math.random() * 20 + 5,
            connections: []
        });
    }
}

function updateNodeConnections() {
    nodes.forEach(node => {
        node.connections = [];
        for (let i = 0; i < maxConnections; i++) {
            const targetIndex = Math.floor(Math.random() * nodeCount);
            if (!node.connections.includes(targetIndex)) {
                node.connections.push(targetIndex);
            }
        }
    });
}

function drawNetworkNodesVisualizer() {
    if (nodes.length === 0) {
        initializeNodes();
    }

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    analyser.getByteFrequencyData(dataArray);

    // Clear the canvas with a dark red background
    canvasCtx.fillStyle =  'rgba(10, 10, 56, 0.2)';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

    // Update node positions
    nodes.forEach(node => {
        node.x += (node.targetX - node.x) * 0.02;
        node.y += (node.targetY - node.y) * 0.03;

        // If node is close to target, set a new target
        if (Math.abs(node.x - node.targetX) < 1 && Math.abs(node.y - node.targetY) < 1) {
            node.targetX = Math.random() * canvas.width;
            node.targetY = Math.random() * canvas.height;
        }
    });

    // Occasionally update connections
    if (Math.random() < 0.01) {
        updateNodeConnections();
    }

    // Draw connections
    nodes.forEach((node, index) => {
        const amplitude = dataArray[index % bufferLength] / 255;
        canvasCtx.strokeStyle = `rgba(0, 0, 255, ${amplitude * 0.5})`;
        canvasCtx.lineWidth = amplitude * 3;

        node.connections.forEach(targetIndex => {
            const targetNode = nodes[targetIndex];
            canvasCtx.beginPath();
            canvasCtx.moveTo(node.x, node.y);
            canvasCtx.lineTo(targetNode.x, targetNode.y);
            canvasCtx.stroke();
        });
    });

    // Draw nodes
    nodes.forEach((node, index) => {
        const amplitude = dataArray[index % bufferLength] / 255;
        const glow = amplitude * 20;

        // Outer glow
        const gradient = canvasCtx.createRadialGradient(
            node.x, node.y, node.radius,
            node.x, node.y, node.radius + glow
        );
        gradient.addColorStop(0, `rgba(0, 0, 200, ${amplitude})`);
        gradient.addColorStop(1, 'rgba(0, 0, 60, 0)');

        canvasCtx.fillStyle = gradient;
        canvasCtx.beginPath();
        canvasCtx.arc(node.x, node.y, node.radius + glow, 0, Math.PI * 2);
        canvasCtx.fill();

        // Inner circle
        canvasCtx.fillStyle = `rgb(0, 0, ${100 + amplitude * 155})`;
        canvasCtx.beginPath();
        canvasCtx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        canvasCtx.fill();
    });
}



		 function isWebGLSupported() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }
		
		  function initThreeJS() {
            if (!isWebGLSupported()) {
                console.log("WebGL is not supported. Skipping 3D visualizer.");
                return false;
            }

            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ canvas: canvas });
                renderer.setSize(canvas.width, canvas.height);

                // Create cubes
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                for (let i = 0; i < 64; i++) {
                    const cube = new THREE.Mesh(geometry, material);
                    cube.position.x = (i % 8) - 3.5;
                    cube.position.z = Math.floor(i / 8) - 3.5;
                    scene.add(cube);
                    cubes.push(cube);
                }

                camera.position.z = 10;
                return true;
            } catch (e) {
                console.error("Error initializing Three.js:", e);
                return false;
            }
        }

        function draw3DVisualizer() {
            if (!isWebGLAvailable) {
                return;
            }

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Clear the scene
            renderer.clear();

            // Update cube heights based on frequency data
            for (let i = 0; i < cubes.length; i++) {
                const value = dataArray[i] / 10;
                cubes[i].scale.y = value < 0.1 ? 0.1 : value;
                cubes[i].material.color.setHSL(i / cubes.length, 1, 0.5);
            }

            // Rotate the entire scene
            scene.rotation.y += 0.01;

            // Render the scene
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            switch(currentVisualizer) {
                case 0:
                    drawBarVisualizer();
                    break;
                case 1:
                    drawParticleVisualizer();
                    break;
                case 2:
                    drawWaveformVisualizer();
                    break;
                case 3:
                    drawCircularVisualizer();
                    break;
                case 4:
                    drawSpectrogramVisualizer();
                    break;
                case 5:
                    drawFractalTreeVisualizer();
                    break;
                case 6:
                    drawKaleidoscopeVisualizer();
                    break;
                case 7:
                    drawGeometricKaleidoscopeVisualizer();
                    break;
                case 8:
                    drawLissajousVisualizer();
                    break;
                case 9:
                    drawFluidSimulationVisualizer();
                    break;
					case 10:
					drawNetworkNodesVisualizer();
					break;
				 case 11:
                    if (isWebGLAvailable) {
                        draw3DVisualizer();
                    } else {
                        currentVisualizer = 0; // Fallback to the first visualizer if WebGL is not available
                        drawBarVisualizer();
                    }
                    break;
				case 12:
                    // This case is for the random visualizer
                    // The actual visualizer is already selected randomly
                    break;
            }
        }
        
         function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            if (currentVisualizer === 1) {
                initParticles();
            }
            if (isWebGLAvailable && currentVisualizer === 11) {
                camera.aspect = canvas.width / canvas.height;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.width, canvas.height);
            }
        }
        
		
		
        window.addEventListener('resize', resizeCanvas);
		 document.addEventListener('fullscreenchange', resizeCanvas);
        resizeCanvas();
        animate();

        // Audio state listener
        audio.addEventListener('play', () => {
            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        });
        audio.addEventListener('pause', () => {
            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
        });

        // Function to update track information
        function updateTrackInfo() {
            fetch('http://130.162.248.119:8000/status-json.xsl')
                .then(response => response.json())
                .then(data => {
                    const trackTitle = data.icestats.source.title || 'Unknown Track';
                    const trackArtist = data.icestats.source.artist || 'Unknown Artist';
                    trackInfoElement.innerHTML = `
                        <div class="now-playing">Now Playing:</div>
                        <div class="track-title-artist">${trackArtist} - ${trackTitle}</div>
                    `;
                })
                .catch(error => {
                    console.error('Error fetching track info:', error);
                    trackInfoElement.innerHTML = `
                        <div class="now-playing">Now Playing:</div>
                        <div class="track-title-artist">Track information unavailable</div>
                    `;
                });
        }

        // Update track info every 30 seconds
        updateTrackInfo();
        setInterval(updateTrackInfo, 30000);
    </script>
</body>
</html>
